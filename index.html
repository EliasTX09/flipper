<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Flipper WertbFlasher</title>
  <style>
    :root{
      --bg:#071423;--card:#0b182a;--ink:#e4f7ff;--muted:#9bb4c3;
      --panel:#020612;--accent:#00e6ff;--accent2:#9b5cff;
    }
    *{box-sizing:border-box}
    body{margin:0;font-family:ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace;background:var(--bg);color:var(--ink)}
    header{text-align:center;padding:20px}
    h1{color:var(--accent);margin:0 0 4px}
    header p{margin:4px 0;color:var(--muted)}
    main{display:flex;flex-wrap:wrap;gap:16px;max-width:1000px;margin:20px auto;padding:0 12px}
    .card{background:var(--card);padding:16px;border-radius:12px;flex:1 1 420px;min-width:320px}
    .row{display:flex;gap:8px;flex-wrap:wrap;align-items:center}
    .console,.filelist{background:var(--panel);padding:10px;border-radius:8px;height:180px;overflow:auto;white-space:pre-wrap;border:1px solid #0f2744}
    .progress{background:#081825;height:10px;border-radius:6px;margin:8px 0;overflow:hidden;border:1px solid #0f2744}
    .bar{height:100%;width:0;background:linear-gradient(90deg,var(--accent),var(--accent2));transition:width .25s ease}
    button{margin:2px 0;padding:10px 12px;border-radius:8px;background:#052033;color:var(--ink);cursor:pointer;border:1px solid #0f2744}
    button:hover{background:#13314b}
    button[disabled]{opacity:.5;cursor:not-allowed}
    input[type="file"]{padding:6px 8px;background:#04192b;border:1px solid #0f2744;border-radius:8px;color:var(--ink)}
    .tag{display:inline-block;padding:2px 8px;border:1px solid #0f2744;border-radius:999px;color:var(--muted);font-size:12px}
  </style>
</head>
<body>
  <header>
    <h1>Flipper WebFlasher</h1>
    <p class="tag">Variante 2: Upload ‚ûú <strong>Reboot in Update-Modus</strong> (ohne Men√º)</p>
  </header>

  <main>
    <!-- Linke Karte: Datei & Verbindung & Upload -->
    <div class="card">
      <h3>1) Datei w√§hlen</h3>
      <div class="row">
        <input type="file" id="fw" accept=".zip,.tgz,.tar.gz,.tar" />
      </div>

      <h3 style="margin-top:14px">2) Verbinden & Upload</h3>
      <div class="row">
        <button id="connect" disabled>üîå Verbinden</button>
        <button id="flash" disabled>‚ö° Upload</button>
        <button id="startUpdate" disabled>‚è© Update jetzt starten</button>
      </div>

      <div class="progress"><div id="bar" class="bar"></div></div>
      <div id="log" class="console">Bereit.</div>
    </div>

    <!-- Rechte Karte: Inhalts√ºbersicht -->
    <div class="card">
      <h3>Inhalt der gew√§hlten Datei</h3>
      <div id="files" class="filelist">(keine Datei)</div>
    </div>
  </main>

  <!-- externe libs -->
  <script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/pako@2.1.0/dist/pako.min.js"></script>

  <!-- App-Logik -->
  <script>
    // ==== UI-Refs
    const fwInput = document.getElementById('fw');
    const btnConnect = document.getElementById('connect');
    const btnFlash = document.getElementById('flash');
    const btnStartUpdate = document.getElementById('startUpdate');
    const logEl = document.getElementById('log');
    const filesEl = document.getElementById('files');
    const barEl = document.getElementById('bar');

    // ==== State
    let selectedEntries = [];     // [{path, data:Uint8Array}]
    let port = null;
    let writer = null;
    let reader = null;
    let isConnected = false;
    let uploadedOK = false;

    // ==== Helpers (UI)
    function log(m) {
      logEl.textContent += "\\n" + m;
      logEl.scrollTop = logEl.scrollHeight;
    }
    function setProgress(p) {
      barEl.style.width = Math.max(0, Math.min(100, p)) + "%";
    }

    // ==== TAR Parser (minimal)
    function parseTar(u8) {
      const files = [];
      const block = 512;
      let off = 0;
      const dec = new TextDecoder();
      const readStr = a => dec.decode(a).replace(/\\0+$/,'').trim();
      while (off + block <= u8.length) {
        const h = u8.subarray(off, off + block);
        const name = readStr(h.subarray(0,100));
        // zwei 0-Bl√∂cke = Ende
        if (!name) {
          const allZero = h.every(b => b === 0);
          off += block;
          if (allZero && off + block <= u8.length) {
            const h2 = u8.subarray(off, off + block);
            if (h2.every(b => b === 0)) break;
          }
          continue;
        }
        const size = parseInt(readStr(h.subarray(124,136)), 8) || 0;
        off += block;
        const data = u8.subarray(off, off + size);
        files.push({ path: name, data: new Uint8Array(data) });
        off += Math.ceil(size / block) * block;
      }
      return files;
    }

    // ==== Datei laden & entpacken
    fwInput.addEventListener('change', async () => {
      setProgress(0);
      uploadedOK = false;
      filesEl.textContent = "(keine Datei)";
      selectedEntries = [];
      btnFlash.disabled = true;
      btnStartUpdate.disabled = true;

      try {
        const file = fwInput.files[0];
        if (!file) { btnConnect.disabled = true; return; }

        const buf = new Uint8Array(await file.arrayBuffer());
        let entries = [];
        const name = file.name.toLowerCase();

        if (name.endsWith('.zip')) {
          const zip = await JSZip.loadAsync(buf);
          for (const k of Object.keys(zip.files)) {
            const e = zip.files[k];
            if (e.dir) continue;
            entries.push({ path: k, data: new Uint8Array(await e.async('uint8array')) });
          }
        } else {
          const tarData = (name.endsWith('.tgz') || name.endsWith('.tar.gz')) ? pako.ungzip(buf) : buf;
          entries = parseTar(tarData);
        }

        if (!entries.length) {
          log("‚ö†Ô∏è Keine Dateien im Archiv gefunden.");
          btnConnect.disabled = true;
          return;
        }

        selectedEntries = entries;
        filesEl.textContent = entries.map(e => \`\${e.path} ‚Ä¢ \${e.data.length} bytes\`).join('\\n');
        log(\`üì¶ \${entries.length} Datei(en) geladen\`);

        // erst JETZT: Verbinden erlauben
        btnConnect.disabled = false;
      } catch (err) {
        log("‚ùå Fehler beim Entpacken: " + err);
        btnConnect.disabled = true;
      }
    });

    // ==== WebSerial ‚Äì verbinden
    btnConnect.addEventListener('click', async () => {
      try {
        if (!('serial' in navigator)) throw new Error("WebSerial API nicht verf√ºgbar (Chrome/Edge Desktop verwenden).");
        port = await navigator.serial.requestPort();
        await port.open({ baudRate: 115200 });

        writer = port.writable.getWriter();
        reader = port.readable.getReader();

        isConnected = true;
        log("‚úÖ Verbunden (Serial ge√∂ffnet)");
        btnFlash.disabled = false;

        // kleine Begr√º√üung: "help" lesen (nicht zwingend, aber nett)
        await serialWriteString("help\\r");
        log("‚ÑπÔ∏è Verbunden. Upload bereit.");

      } catch (e) {
        log("‚ùå Verbinden fehlgeschlagen: " + e);
      }
    });

    // ==== Upload (Demo) ‚Äì Dateien nach /ext/update/*
    btnFlash.addEventListener('click', async () => {
      if (!isConnected) { log("‚ö†Ô∏è Nicht verbunden."); return; }
      if (!selectedEntries.length) { log("‚ö†Ô∏è Keine Firmware geladen."); return; }

      try {
        // In echtem RPC w√ºrdest du hier Storage.Write per RPC senden.
        // Wir zeigen den Fortschritt & tun so, als w√ºrden wir an das Ziel schreiben.
        // (CLI-basiertes File-Pushen ist nicht standardisiert; echter RPC folgt optional.)
        let i = 0;
        setProgress(10);
        log("‚û°Ô∏è Starte Upload in /ext/update/ (Demo/Fortschritt) ...");

        for (const e of selectedEntries) {
          i++;
          log(\`‚û°Ô∏è Upload \${e.path}\`);
          // Hier nur ein NOP-Write an die serielle Leitung, damit der Port "lebt".
          await serialWriteBytes(new TextEncoder().encode("# uploading " + e.path + "\\r"));
          await sleep(60);
          log(\`‚úÖ Fertig: \${e.path} (\${i}/\${selectedEntries.length})\`);
          setProgress(10 + Math.floor(80 * (i / selectedEntries.length)));
        }

        uploadedOK = true;
        setProgress(100);
        log("üéâ Upload abgeschlossen (Demo).");
        // Jetzt darf man das Update triggern:
        btnStartUpdate.disabled = false;
      } catch (err) {
        log("‚ùå Upload-Fehler: " + err);
      }
    });

    // ==== Variante 2: Reboot in Update-Modus (CLI)
    btnStartUpdate.addEventListener('click', async () => {
      if (!isConnected) { log("‚ö†Ô∏è Nicht verbunden."); return; }
      if (!uploadedOK) { log("‚ö†Ô∏è Erst hochladen, dann Update starten."); return; }

      try {
        log("‚è© Sende Befehl: reboot update");
        await serialWriteString("reboot update\\r");

        // Leser freigeben, Port schlie√üen (das Ger√§t wird neu starten)
        try { reader && reader.releaseLock(); } catch {}
        try { writer && writer.releaseLock(); } catch {}
        try { await port.close(); } catch {}

        isConnected = false;
        log("üîÅ Ger√§t startet jetzt in den Update-Modus. Warten, bis Update durchgelaufen ist.");
      } catch (e) {
        log("‚ùå Konnte Update-Reboot nicht ausl√∂sen: " + e);
        log("üí° Fallback: Am Flipper im Men√º: Browser ‚ûú Update (falls vorhanden) manuell starten.");
      }
    });

    // ==== Serielle Hilfsfunktionen
    function sleep(ms){ return new Promise(r => setTimeout(r, ms)); }

    async function serialWriteString(str) {
      if (!writer) throw new Error("Writer nicht bereit");
      await writer.write(new TextEncoder().encode(str));
    }

    async function serialWriteBytes(u8) {
      if (!writer) throw new Error("Writer nicht bereit");
      await writer.write(u8);
    }

    // Optional: einfache serielle Leseroutine (Log)
    (async function readLoop(){
      for(;;){
        try{
          if (!reader) { await sleep(150); continue; }
          const { value, done } = await reader.read();
          if (done) { await sleep(150); continue; }
          if (value && value.length){
            const text = new TextDecoder().decode(value);
            if (text.trim()) log("‚üµ " + text.trim());
          }
        }catch(e){
          // Reader wurde evtl. freigegeben, ignorieren
          await sleep(200);
        }
      }
    })();
  </script>
</body>
</html>
