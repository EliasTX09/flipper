<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Flipper WebFlasher (Variante B)</title>
  <style>
    :root{
      --bg:#071423;--card:#0b182a;--ink:#e4f7ff;--ink-dim:#9cb6c4;
      --hl:#00e6ff;--hl2:#9b5cff;--well:#020612;--well2:#081825;--btn:#052033;--btnH:#13314b;
    }
    *{box-sizing:border-box}
    body{margin:0;font-family:ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace;background:var(--bg);color:var(--ink)}
    header{text-align:center;padding:20px}
    h1{color:var(--hl);margin:0 0 6px}
    .sub{color:var(--ink-dim);font-size:12px}
    main{display:flex;gap:16px;max-width:980px;margin:20px auto;padding:0 12px;flex-wrap:wrap}
    .card{background:var(--card);padding:16px;border-radius:10px;flex:1;min-width:320px}
    .row{display:flex;gap:8px;flex-wrap:wrap;align-items:center}
    .console,.filelist{background:var(--well);padding:10px;border-radius:8px;height:220px;overflow:auto;white-space:pre-wrap;font-size:12px;line-height:1.35}
    .filelist{height:180px}
    .progress{background:var(--well2);height:10px;border-radius:6px;margin:8px 0;overflow:hidden}
    .bar{height:100%;width:0;background:linear-gradient(90deg,var(--hl),var(--hl2))}
    .bar2{height:6px;background:linear-gradient(90deg,var(--hl),var(--hl2));width:0;border-radius:6px}
    button{margin:4px 0;padding:8px 10px;border-radius:6px;background:var(--btn);color:var(--ink);cursor:pointer;border:1px solid #0f3350}
    button:hover{background:var(--btnH)}
    button:disabled{opacity:.5;cursor:not-allowed}
    .pill{padding:4px 8px;border-radius:999px;background:#052033;border:1px solid #0f3350;color:#a8d4e6;font-size:12px}
    input[type=file]{accent-color:var(--hl)}
    .hint{font-size:12px;color:var(--ink-dim);margin-top:6px}
    .ok{color:#7fffd4}
    .bad{color:#ff8a8a}
    .sep{height:1px;background:#102236;margin:10px 0}
    .grid{display:grid;grid-template-columns:1fr auto;gap:8px;align-items:center}
    a.link{color:var(--hl)}
  </style>
</head>
<body>
  <header>
    <h1>Flipper WebFlasher</h1>
    <div class="sub">Variante B ¬∑ Upload nach <code>/ext/update</code> ‚Üí <code>update start ‚Ä¶</code> ‚Üí Live-Log</div>
  </header>

  <main>
    <div class="card" style="flex:1.1">
      <div class="grid">
        <div class="row">
          <input type="file" id="fw" accept=".zip,.tgz,.tar.gz,.tar" />
          <span id="fwInfo" class="pill">keine Datei</span>
        </div>
        <div class="row">
          <button id="connect" disabled>üîå Verbinden</button>
          <button id="reboot" disabled>‚ôªÔ∏è Reboot</button>
        </div>
      </div>

      <div class="progress"><div id="bar" class="bar"></div></div>

      <div class="row" style="gap:6px">
        <button id="flash" disabled>‚ö° Upload & Update</button>
        <button id="list" disabled>üìÇ /ext/update anzeigen</button>
        <button id="cancel" disabled>üõë Abbrechen</button>
      </div>

      <div id="log" class="console">Bereit. Datei w√§hlen, dann verbinden.</div>

      <div class="hint">
        Tipp: In Chrome/Edge √∂ffnen. Wenn ‚ÄûPort √∂ffnen fehlgeschlagen‚Äú ‚Üí USB-Kabel/Port wechseln, andere Programme schlie√üen (qFlipper/Flipper Mobile/Serial Monitor).
      </div>
    </div>

    <div class="card" style="flex:.9">
      <h3 style="margin:0 0 8px">Inhalt des Archivs</h3>
      <div id="files" class="filelist">(keine Datei)</div>
      <div class="sep"></div>
      <div class="row" style="justify-content:space-between">
        <div>
          Erkanntes Manifest: <code id="manifestLabel">‚Äì</code>
          <div class="bar2" id="opBar" style="margin-top:6px"></div>
        </div>
        <span id="devState" class="pill">Getrennt</span>
      </div>
    </div>
  </main>

  <!-- externe libs -->
  <script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/pako@2.1.0/dist/pako.min.js"></script>

  <script>
    // ---------- UI-Helfer ----------
    const $ = sel => document.querySelector(sel);
    const logEl = $('#log');
    const barEl = $('#bar');
    const opBarEl = $('#opBar');
    const filesEl = $('#files');
    const fwInput = $('#fw');
    const fwInfo = $('#fwInfo');
    const btnConnect = $('#connect');
    const btnReboot  = $('#reboot');
    const btnFlash = $('#flash');
    const btnList = $('#list');
    const btnCancel = $('#cancel');
    const devState = $('#devState');

    function log(m){ logEl.textContent += (logEl.textContent ? '\\n' : '') + m; logEl.scrollTop = logEl.scrollHeight; }
    function setProgress(p){ barEl.style.width = Math.max(0, Math.min(100, p)) + '%'; }
    function setOp(p){ opBarEl.style.width = Math.max(0, Math.min(100, p)) + '%'; }

    // ---------- Archiv entpacken ----------
    function parseTar(u8){
      const files=[]; const block=512; let off=0;
      const dec=new TextDecoder(); const readStr=a=>dec.decode(a).replace(/\\0+$/,'').trim();
      while(off+block<=u8.length){
        const h=u8.subarray(off,off+block);
        const name=readStr(h.subarray(0,100));
        if(!name){ if(h.every(b=>b===0)) break; off+=block; continue; }
        const size=parseInt(readStr(h.subarray(124,136)),8)||0;
        off+=block;
        const data=u8.subarray(off,off+size);
        files.push({path:name,data:new Uint8Array(data)});
        off+=Math.ceil(size/block)*block;
      }
      return files;
    }

    let selectedEntries = [];
    let manifestPath = null;

    fwInput.addEventListener('change', async () => {
      filesEl.textContent = '(keine Datei)';
      selectedEntries = [];
      manifestPath = null;
      setOp(0); setProgress(0);
      try{
        const file = fwInput.files[0];
        if(!file){ fwInfo.textContent='keine Datei'; btnConnect.disabled = true; btnFlash.disabled = true; return; }
        fwInfo.textContent = file.name + ' ‚Ä¢ ' + (file.size/1024).toFixed(1) + ' KB';

        const buf = new Uint8Array(await file.arrayBuffer());
        const name = file.name.toLowerCase();
        let entries = [];

        if(name.endsWith('.zip')){
          const zip = await JSZip.loadAsync(buf);
          for(const k of Object.keys(zip.files)){
            const e = zip.files[k];
            if(e.dir) continue;
            const bytes = new Uint8Array(await e.async('uint8array'));
            entries.push({ path:k, data:bytes });
          }
        }else{
          const tarData = (name.endsWith('.tgz')||name.endsWith('.tar.gz')) ? pako.ungzip(buf) : buf;
          entries = parseTar(tarData);
        }

        // normalisieren & Manifest finden
        entries = entries.map(e => ({ path:e.path.replace(/\\\\/g,'/').replace(/^\\/+/,''), data:e.data }));
        const fuf = entries.find(e => /(^|\\/)update\\.fuf$/i.test(e.path));
        manifestPath = fuf ? fuf.path : null;

        selectedEntries = entries;
        filesEl.textContent = entries.map(e => \`\${e.path} ‚Ä¢ \${e.data.length} bytes\`).join('\\n');
        $('#manifestLabel').textContent = manifestPath || 'nicht gefunden';
        log(\`üì¶ \${entries.length} Datei(en) im Archiv\`);
        // Jetzt darf man verbinden
        btnConnect.disabled = false;
        btnFlash.disabled = true; // erst wenn verbunden
      }catch(err){
        fwInfo.textContent='Fehler';
        log('‚ùå Fehler beim Entpacken: '+err);
        btnConnect.disabled = true;
        btnFlash.disabled = true;
      }
    });

    // ---------- WebSerial / CLI ----------
    const sleep = ms => new Promise(r=>setTimeout(r,ms));
    let port = null;
    let reader = null;
    let writer = null;
    let readLoopAbort = false;
    let lineBuf = '';

    async function openPort(){
      if(!('serial' in navigator)) throw new Error('WebSerial API nicht verf√ºgbar (Chrome/Edge nutzen).');
      port = await navigator.serial.requestPort();
      await port.open({ baudRate: 115200 });
      writer = port.writable.getWriter();
      reader = port.readable.getReader();
      readLoopAbort = false;
      readLoop(); // ohne await, l√§uft parallel
    }

    async function closePort(){
      try{ readLoopAbort = true; if(reader){ try{ reader.releaseLock(); }catch{} } }catch{}
      try{ if(writer){ try{ writer.releaseLock(); }catch{} }catch{}
      try{ if(port) await port.close(); }catch{}
      port = reader = writer = null;
    }

    async function readLoop(){
      const dec = new TextDecoder();
      try{
        while(!readLoopAbort){
          const { value, done } = await reader.read();
          if(done) break;
          if(value){
            const chunk = dec.decode(value);
            lineBuf += chunk;
            // log raw to console
            const lines = lineBuf.split(/\\r?\\n/);
            lineBuf = lines.pop() ?? '';
            for(const ln of lines){
              if(ln.trim()) log('üìü ' + ln);
              // einfache Progress-Sch√§tzung bei Prozentangaben
              const m = ln.match(/(\\d{1,3})%/);
              if(m){ setOp(+m[1]); }
            }
          }
        }
      }catch(e){
        if(!readLoopAbort) log('‚ö†Ô∏è readLoop: '+e);
      }
    }

    async function cliWriteLine(s){
      const enc = new TextEncoder();
      await writer.write(enc.encode(s.endsWith('\\r')||s.endsWith('\\n') ? s : (s+'\\r')));
    }

    async function cliWriteRaw(bytes){
      // Rohbytes senden (f√ºr storage write Datenphase)
      await writer.write(bytes);
    }

    // Einige Flipper-CLI-Befehle
    async function cliMkdir(p){ await cliWriteLine('storage mkdir ' + p); }
    async function cliList(p){ await cliWriteLine('storage list ' + p); }
    async function cliReboot(){ await cliWriteLine('reboot'); }
    async function cliUpdateStart(p){ await cliWriteLine('update start ' + p); }

    // **WICHTIG**: Chunked Upload √ºber CLI
    // Flipper-CLI erwartet f√ºr "storage write <path> <len>" anschlie√üend genau <len> Rohbytes.
    async function cliStorageWrite(path, data, chunk=1024){
      await cliWriteLine(\`storage remove \${path}\`); // ignorier Fehler
      await sleep(30);
      await cliWriteLine(\`storage write \${path} \${data.length}\`);
      await sleep(20);
      let sent=0;
      while(sent < data.length){
        const part = data.subarray(sent, Math.min(data.length, sent+chunk));
        await cliWriteRaw(part);
        sent += part.length;
        setProgress(Math.round((sent/data.length)*80)+5);
        await sleep(2);
      }
      // ein kleines Delay, damit das Ger√§t die Daten abschlie√üen kann
      await sleep(60);
    }

    // ---------- UI Actions ----------
    btnConnect.addEventListener('click', async ()=>{
      try{
        btnConnect.disabled = true;
        await openPort();
        devState.textContent = 'Verbunden';
        devState.style.background = '#0c3a2d';
        devState.style.color = '#a6ffd6';
        log('‚úÖ Verbunden. CLI bereit.');
        btnFlash.disabled = false;
        btnList.disabled = false;
        btnCancel.disabled = false;
        btnReboot.disabled = false;
      }catch(e){
        log('‚ùå Verbinden fehlgeschlagen: ' + e);
        btnConnect.disabled = false;
      }
    });

    btnCancel.addEventListener('click', async ()=>{
      btnCancel.disabled = true;
      try{
        await closePort();
        log('‚èπÔ∏è Verbindung geschlossen.');
      }catch(e){ log('‚ö†Ô∏è close: ' + e); }
      devState.textContent = 'Getrennt';
      devState.style.background = '#052033';
      devState.style.color = '#a8d4e6';
      btnConnect.disabled = (fwInput.files.length===0);
      btnFlash.disabled = true;
      btnList.disabled = true;
      btnReboot.disabled = true;
    });

    btnReboot.addEventListener('click', async ()=>{
      try{
        await cliReboot();
        log('‚ôªÔ∏è Reboot angefordert.');
      }catch(e){ log('‚ùå Reboot-Fehler: '+e); }
    });

    btnList.addEventListener('click', async ()=>{
      try{
        await cliList('/ext/update');
      }catch(e){ log('‚ùå storage list: '+e); }
    });

    btnFlash.addEventListener('click', async ()=>{
      if(!port || !writer){ log('‚ö†Ô∏è Bitte zuerst verbinden.'); return; }
      if(!selectedEntries.length){ log('‚ö†Ô∏è Keine Firmware geladen.'); return; }

      try{
        setProgress(5); setOp(0);
        log('‚û°Ô∏è Erstelle /ext/update ‚Ä¶');
        await cliMkdir('/ext/update');
        await sleep(30);

        // Upload aller Dateien
        let i=0;
        for(const e of selectedEntries){
          i++;
          const target = '/ext/update/' + e.path.replace(/^\\/+/, '');
          log(\`‚¨ÜÔ∏è Upload: \${target} (\${e.data.length} bytes)\`);
          await cliStorageWrite(target, e.data, 1024);
          log(\`‚úÖ Fertig: \${e.path} (\${i}/\${selectedEntries.length})\`);
        }
        setProgress(90);

        if(!manifestPath){
          log('‚ö†Ô∏è Kein update.fuf im Archiv gefunden. Update-Start wird √ºbersprungen.');
          log('‚ÑπÔ∏è Variante: Starte Update manuell am Ger√§t: Main Menu ‚Üí System ‚Üí Update ‚Üí From SD Card ‚Üí /ext/update/‚Ä¶');
          setProgress(100);
          return;
        }

        // Update starten
        const manifest = '/ext/update/' + manifestPath.replace(/^\\/+/, '');
        log('üöÄ Starte Update: ' + manifest);
        await cliUpdateStart(manifest);

        // Warten & Log anzeigen (Flipper gibt Prozent/Status aus)
        // Wir lassen die readLoop laufen; hier nur grobes Warten und UI blocken
        setProgress(95);
        log('‚è≥ Warte auf Updater-Ausgaben‚Ä¶ (nicht trennen)');
        // Optionale Wartezeit ‚Äì die echte Progress kommt aus der ser. Ausgabe
        const start = Date.now();
        while(Date.now() - start < 180000){ // bis 3 Min
          await sleep(500);
        }

        setProgress(100);
        log('üéâ Upload abgeschlossen. Update sollte laufen.');
        log('Falls der Bildschirm nicht im Update-Modus ist: Men√º ‚Üí System ‚Üí Update ‚Üí From SD ‚Üí /ext/update/update.fuf');

      }catch(err){
        log('‚ùå Upload/Update-Fehler: '+err);
      }
    });

    // Datei gew√§hlt? Dann darf man verbinden
    fwInput.addEventListener('change', ()=>{
      btnConnect.disabled = !(fwInput.files && fwInput.files.length>0);
    });
  </script>
</body>
</html>
