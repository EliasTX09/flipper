<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Flipper WebFlasher</title>
  <style>
    body{margin:0;font-family:monospace;background:#071423;color:#e4f7ff}
    header{text-align:center;padding:20px}
    h1{color:#00e6ff}
    main{display:flex;gap:16px;max-width:900px;margin:20px auto;flex-wrap:wrap}
    .card{background:#0b182a;padding:16px;border-radius:8px;flex:1;min-width:320px}
    .console,.filelist{background:#020612;padding:8px;border-radius:6px;height:180px;overflow:auto;white-space:pre-wrap}
    .progress{background:#081825;height:10px;border-radius:6px;margin:8px 0}
    .bar{height:100%;width:0;background:linear-gradient(90deg,#00e6ff,#9b5cff)}
    button{margin:4px;padding:8px;border-radius:4px;background:#052033;color:#e4f7ff;cursor:pointer;border:0}
    button:hover{background:#13314b}
    button:disabled{opacity:.5;cursor:not-allowed}
    .row{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
    small.muted{opacity:.7}
  </style>
</head>
<body>
  <header>
    <h1>Flipper WebFscdwlasher</h1>
    <small class="muted">Ben√∂tigt Chrome/Edge (Desktop) √ºber HTTPS (GitHub Pages).</small>
  </header>

  <main>
    <div class="card">
      <div class="row">
        <input type="file" id="fw" accept=".zip,.tgz,.tar.gz" />
        <button id="connect">üîå Verbinden</button>
        <button id="flash" disabled>‚ö° Upload</button>
        <button id="reboot" disabled>üîÑ Reboot</button>
      </div>
      <div class="progress"><div id="bar" class="bar"></div></div>
      <div id="log" class="console">Bereit.</div>
    </div>

    <div class="card">
      <h3>Inhalt:</h3>
      <div id="files" class="filelist">(keine Datei)</div>
    </div>
  </main>

  <!-- Libs -->
  <script defer src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>
  <script defer src="https://cdn.jsdelivr.net/npm/pako@2.1.0/dist/pako.min.js"></script>

  <!-- WICHTIG: Eigene Dateien vom gleichen Origin laden (Repo selbst), NICHT raw.githubusercontent -->
  <script defer src="notoga.js"></script>
  <script defer src="./flipper-rpc.js"></script>

  <script>
  // ===== Mini-Helper =====
  const $ = sel => document.querySelector(sel);
  const logEl = $('#log');
  const filesEl = $('#files');
  const barEl = $('#bar');
  const btnConnect = $('#connect');
  const btnFlash = $('#flash');
  const btnReboot = $('#reboot');
  const fwInput = $('#fw');

  let connected = false;
  let selectedEntries = [];

  function log(m){ logEl.textContent += "\\n" + m; logEl.scrollTop = logEl.scrollHeight; }
  function setProgress(p){ barEl.style.width = Math.max(0, Math.min(100, p)) + '%'; }
  function updateButtons(){
    btnFlash.disabled  = !(connected && selectedEntries.length>0);
    btnReboot.disabled = !connected;
  }

  // ===== TAR Parser =====
  function parseTar(u8){
    const files=[]; const block=512; let off=0;
    const dec=new TextDecoder(); const readStr=a=>dec.decode(a).replace(/\\0+$/,'').trim();
    while(off+block<=u8.length){
      const h=u8.subarray(off,off+block);
      const name=readStr(h.subarray(0,100));
      if(!name){ if(h.every(b=>b===0)) break; off+=block; continue; }
      const size=parseInt(readStr(h.subarray(124,136)),8)||0; off+=block;
      const data=u8.subarray(off,off+size);
      files.push({path:name,data:new Uint8Array(data)});
      off+=Math.ceil(size/block)*block;
    }
    return files;
  }

  // ===== Self-Check =====
  window.addEventListener('DOMContentLoaded', () => {
    if (!('serial' in navigator)) {
      log('‚ùå WebSerial nicht verf√ºgbar. Nutze Chrome/Edge (Desktop) √ºber HTTPS.');
    } else {
      log('‚úÖ WebSerial verf√ºgbar.');
    }
    if (!window.flipper) {
      log('‚ùå notoga.js nicht geladen. Pr√ºfe, ob ./notoga.js im Repo liegt und korrekt served wird.');
    } else {
      log('‚úÖ notoga.js geladen.');
    }
    if (typeof window.protobuf === 'undefined') {
      log('‚ÑπÔ∏è flipper-rpc.js (protobuf) optional ‚Äî f√ºr echten RPC notwendig.');
    } else {
      log('‚úÖ flipper-rpc.js geladen.');
    }
  });

  // ===== Datei laden / entpacken =====
  fwInput.addEventListener('change', async () => {
    filesEl.textContent = '(keine Datei)';
    selectedEntries = [];
    setProgress(0);
    try{
      const file = fwInput.files[0];
      if(!file){ log('‚ö†Ô∏è Keine Datei gew√§hlt.'); updateButtons(); return; }
      log(`üì¶ Lade ${file.name} ...`);
      const buf = new Uint8Array(await file.arrayBuffer());
      let entries=[];
      const name = file.name.toLowerCase();

      if(name.endsWith('.zip')){
        const zip = await JSZip.loadAsync(buf);
        for(const k of Object.keys(zip.files)){
          const e = zip.files[k]; if(e.dir) continue;
          entries.push({path:k, data:new Uint8Array(await e.async('uint8array'))});
        }
      }else{
        const tarData = (name.endsWith('.tgz')||name.endsWith('.tar.gz')) ? pako.ungzip(buf) : buf;
        entries = parseTar(tarData);
      }

      selectedEntries = entries;
      filesEl.textContent = entries.map(e => `${e.path} ‚Ä¢ ${e.data.length} bytes`).join('\\n') || '(leer)';
      log(`‚úÖ ${entries.length} Datei(en) geladen`);
    }catch(err){
      log('‚ùå Fehler beim Entpacken: ' + err);
      selectedEntries = [];
    }
    updateButtons();
  });

  // ===== Verbinden =====
  btnConnect.addEventListener('click', async () => {
    try{
      if(!('serial' in navigator)) {
        log('‚ùå WebSerial nicht verf√ºgbar (Chrome/Edge Desktop, HTTPS).');
        return;
      }
      if(!window.flipper || !window.flipper.connect){
        log('‚ùå flipper-API fehlt (notoga.js nicht geladen).');
        return;
      }
      log('üîå √ñffne Port-Dialog ...');
      await window.flipper.connect();                 // √∂ffnet Port + baud 115200 (notoga.js)
      await window.flipper.commands.startRpcSession();// Dummy "rpc started" ‚Üí zeigt, dass JS l√§uft
      connected = true;
      log('‚úÖ Verbunden & RPC gestartet');
    }catch(e){
      log('‚ùå Verbinden fehlgeschlagen: ' + e);
      connected = false;
    }
    updateButtons();
  });

  // ===== Upload =====
  btnFlash.addEventListener('click', async () => {
    if(!connected){ log('‚ö†Ô∏è Erst verbinden.'); return; }
    if(!selectedEntries.length){ log('‚ö†Ô∏è Keine Firmware geladen.'); return; }

    try{
      let i=0;
      setProgress(10);
      for(const e of selectedEntries){
        i++;
        log(`‚û°Ô∏è Upload ${e.path}`);
        // Achtung: notoga.js hat aktuell nur eine Platzhalter-Implementierung!
        await window.flipper.commands.storage.write('/ext/update/'+e.path, e.data);
        log(`‚úÖ ${e.path} (${i}/${selectedEntries.length})`);
        setProgress(10 + Math.floor(80*(i/selectedEntries.length)));
      }
      setProgress(100);
      log('üéâ Upload abgeschlossen. (Echter RPC-Write braucht die richtige Implementierung!)');
    }catch(err){
      log('‚ùå Upload-Fehler: ' + err);
    }
  });

  // ===== Reboot (UPDATE) =====
  btnReboot.addEventListener('click', async () => {
    if(!connected){ log('‚ö†Ô∏è Erst verbinden.'); return; }
    try{
      // Platzhalter: hier m√ºsste die echte PB_Frame + PB_System.RebootRequest (mode=UPDATE) gesendet werden.
      log('üîÑ Reboot-Request (UPDATE) wird gesendet ...');
      // TODO: implementiere echtes Senden √ºber den ge√∂ffneten Serial-Port (nicht nur console.log)
      log('‚ÑπÔ∏è Aktuell ist das nur ein Stub. F√ºr echten Reboot brauchst du die echte RPC-Frame-Serialisierung.');
    }catch(e){
      log('‚ùå Reboot fehlgeschlagen: ' + e);
    }
  });

  </script>
</body>
</html>
