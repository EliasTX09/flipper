<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="utf-8" />
  <title>Flipper WebFlasher (RPC + Fallback)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root { color-scheme: dark; }
    body { font-family: system-ui, Arial, sans-serif; background:#0b0b0f; color:#e8e8ef; margin:0; }
    header { padding:16px 20px; background:#101018; border-bottom:1px solid #1e1e2a; display:flex; align-items:center; gap:12px; }
    h1 { font-size:18px; margin:0; }
    main { padding:20px; max-width:900px; margin:auto; }
    .row { display:flex; flex-wrap:wrap; gap:10px; align-items:center; margin:10px 0 16px; }
    button, label[role="button"] {
      background:#1b1b26; border:1px solid #2a2a3a; color:#e8e8ef; padding:10px 14px; border-radius:8px; cursor:pointer; font-weight:600;
    }
    button:hover, label[role="button"]:hover { background:#222235; }
    button:disabled { opacity:.5; cursor:not-allowed; }
    input[type="file"] { display:none; }
    .card { background:#11121a; border:1px solid #222235; border-radius:12px; padding:14px; margin:12px 0; }
    .log { background:#0f1017; border:1px solid #202132; border-radius:10px; height:300px; overflow:auto; white-space:pre-wrap; padding:10px; font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace; font-size:12px; }
    .bad { color:#ff7171; }
    .ok { color:#90ee90; }
    .muted { color:#9aa; }
    .progress { height:10px; background:#171725; border:1px solid #2a2a3a; border-radius:999px; overflow:hidden; }
    .bar { height:100%; width:0%; background:#30d158; transition:width .1s linear; }
    .pill { padding:4px 8px; border-radius:999px; border:1px solid #2a2a3a; background:#151524; font-size:11px; }
    .grid { display:grid; grid-template-columns: 1fr 1fr; gap:16px; }
    @media (max-width: 800px) { .grid { grid-template-columns: 1fr; } }
  </style>

  <!-- Libraries -->
  <script src="https://cdn.jsdelivr.net/npm/protobufjs@7.2.6/dist/protobuf.light.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/fflate@0.8.2/umd/index.min.js"></script>

  <!-- Deine RPC-Bundle-Datei via jsDelivr (achte auf den Pfad & Branch!) -->
  <script src="https://cdn.jsdelivr.net/gh/EliasTX09/flipper@main/flipper-rpc.browser.js"></script>
</head>
<body>
  <header>
    <h1>‚ö° Flipper WebFlasher</h1>
    <span id="wsState" class="pill">WebSerial: ‚Ä¶</span>
    <span id="rpcState" class="pill">RPC: ‚Ä¶</span>
  </header>

  <main>
    <div class="row">
      <button id="btnConnect">üîå Connect</button>
      <button id="btnDisconnect" disabled>‚ùå Disconnect</button>
      <button id="btnReboot" disabled>üîÑ Reboot</button>
      <button id="btnPing" disabled>üèì Ping</button>
    </div>

    <div class="grid">
      <section class="card">
        <h3>üì¶ Firmware (.tgz) hochladen & Update starten</h3>
        <div class="row">
          <label role="button">
            üìÅ Datei w√§hlen
            <input id="fwFile" type="file" accept=".tgz" />
          </label>
          <button id="btnUpload" disabled>‚¨ÜÔ∏è Upload nach /ext/update</button>
          <button id="btnUpdate" disabled>üöÄ Update starten (RPC)</button>
        </div>
        <div class="progress"><div id="bar" class="bar"></div></div>
        <small class="muted">Ablauf: Datei ‚Üí Upload via RPC ‚Üí Manifest aus TGZ lesen ‚Üí <code>system.update(manifest)</code> senden.</small>
      </section>

      <section class="card">
        <h3>üñ•Ô∏è Terminal</h3>
        <div class="row">
          <input id="cliInput" class="pill" style="flex:1" placeholder="CLI-Befehl (z.B. help) & Enter" />
          <button id="btnSend">‚ñ∂Ô∏è Senden</button>
        </div>
        <div id="log" class="log" aria-live="polite"></div>
      </section>
    </div>
  </main>

  <script>
    // ------------- UI helpers -------------
    const $log = document.getElementById('log');
    const $bar = document.getElementById('bar');
    const $ws = document.getElementById('wsState');
    const $rpc = document.getElementById('rpcState');

    const $btnConnect = document.getElementById('btnConnect');
    const $btnDisconnect = document.getElementById('btnDisconnect');
    const $btnReboot = document.getElementById('btnReboot');
    const $btnPing = document.getElementById('btnPing');
    const $btnUpload = document.getElementById('btnUpload');
    const $btnUpdate = document.getElementById('btnUpdate');
    const $fwFile = document.getElementById('fwFile');
    const $cliInput = document.getElementById('cliInput');
    const $btnSend = document.getElementById('btnSend');

    const ts = () => new Date().toLocaleTimeString();
    function log(line, cls='') {
      const prefix = `[${ts()}] `;
      const span = document.createElement('div');
      if (cls) span.className = cls;
      span.textContent = prefix + line;
      $log.appendChild(span);
      $log.scrollTop = $log.scrollHeight;
    }
    function setBar(p) { $bar.style.width = Math.max(0, Math.min(100, p|0)) + '%'; }
    function setWS(ok, txt) { $ws.textContent = `WebSerial: ${txt}`; $ws.style.borderColor = ok?'#2f6':'#f66'; }
    function setRPC(ok, txt) { $rpc.textContent = `RPC: ${txt}`; $rpc.style.borderColor = ok?'#2f6':'#f66'; }
    function enableConnectedUI(yes) {
      $btnDisconnect.disabled = !yes;
      $btnReboot.disabled = !yes;
      $btnPing.disabled = !yes;
      $btnUpload.disabled = !yes;
      $btnUpdate.disabled = !yes;
      $btnConnect.disabled = yes;
    }

    // ------------- Bridge: window.flipper -------------
    // Manche Bundles exportieren nicht automatisch auf window.
    (function ensureWindowFlipper() {
      try {
        const w = window;
        const maybe = w.flipper || {};
        const g = (name) => w[name] || maybe[name] || null;

        if (!w.flipper) {
          w.flipper = {
            connect: g('connect'),
            disconnect: g('disconnect'),
            write: g('write'),
            read: g('read'),
            closeReader: g('closeReader'),
            commands: g('commands'),
            emitter: g('emitter'),
          };
          log('‚ö†Ô∏è window.flipper neu gesetzt', 'muted');
        }

        const keys = Object.keys(w.flipper).filter(Boolean);
        log('üîé window.flipper Keys: ' + keys.join(', '), 'muted');
      } catch (e) {
        log('‚ùå Fehler beim Setzen von window.flipper: ' + e, 'bad');
      }
    })();

    // ------------- Fallback (nur wenn Bundle keine connect()/disconnect() bereitstellt) -------------
    let port, reader, writer, readLoopActive = false;
    async function fallbackConnect() {
      if (!('serial' in navigator)) throw new Error('Web Serial nicht verf√ºgbar');
      port = await navigator.serial.requestPort({});
      await port.open({ baudRate: 115200 });
      writer = port.writable.getWriter();
      reader = port.readable.getReader();
      readLoopActive = true;
      (async () => {
        const dec = new TextDecoder();
        while (readLoopActive) {
          const { value, done } = await reader.read();
          if (done) break;
          if (value) log(dec.decode(value));
        }
      })().catch(err => log('‚ùå Read-Loop Fehler: ' + err, 'bad'));
      log('‚úÖ Verbunden (Fallback CLI). Warte auf Ausgabe‚Ä¶', 'ok');
    }
    async function fallbackDisconnect() {
      readLoopActive = false;
      try { reader && reader.releaseLock(); } catch {}
      try { await port.close(); } catch {}
      port = reader = writer = null;
      log('üîå Getrennt (Fallback CLI).');
    }
    async function fallbackWrite(text) {
      if (!writer) throw new Error('Nicht verbunden (Fallback)');
      const enc = new TextEncoder();
      await writer.write(enc.encode(text));
    }

    // ------------- Hilfen: RPC-Verf√ºgbarkeit -------------
    const hasRPC = () => !!(window.flipper && window.flipper.commands && window.flipper.connect);

    // ------------- Events aus RPC (Progress etc.) -------------
    (function hookEmitter() {
      if (window.flipper && window.flipper.emitter && typeof window.flipper.emitter.on === 'function') {
        window.flipper.emitter.on('storageWriteRequest/progress', ({progress, total}) => {
          const pct = total ? (progress*100/total) : 0;
          setBar(pct);
        });
      }
    })();

    // ------------- Datei-Helfer -------------
    async function fileToU8(file) {
      const buf = await file.arrayBuffer();
      return new Uint8Array(buf);
    }

    // Gunzip + TAR minimal: finde update.fuf
    function findUpdateFufInTgz(tgzU8) {
      try {
        // 1) gunzip
        const tar = fflate.gunzipSync(tgzU8);
        // 2) primitive TAR-Reader
        let off = 0;
        const dec = new TextDecoder();
        while (off + 512 <= tar.length) {
          const header = tar.subarray(off, off + 512);
          // leeres Ende?
          if (header.every(b => b === 0)) break;
          const nameRaw = header.subarray(0, 100);
          const name = dec.decode(nameRaw).replace(/\0.*$/, '');
          const sizeOct = dec.decode(header.subarray(124, 136)).replace(/\0.*$/, '').trim();
          const size = parseInt(sizeOct, 8) || 0;
          const dataStart = off + 512;
          const dataEnd = dataStart + size;
          const data = tar.subarray(dataStart, dataEnd);
          if (name.endsWith('update.fuf') || name === 'update.fuf') {
            log('‚úÖ update.fuf gefunden im TGZ: ' + name, 'ok');
            return data; // Uint8Array
          }
          // n√§chste Datei, 512-Alignment
          const pad = (512 - (size % 512)) % 512;
          off = dataEnd + pad;
        }
        log('‚ö†Ô∏è Kein update.fuf im TGZ gefunden', 'bad');
        return null;
      } catch (e) {
        log('‚ùå TGZ-Parsing-Fehler: ' + e, 'bad');
        return null;
      }
    }

    // ------------- Button-Handler -------------
    $btnConnect.addEventListener('click', async () => {
      log('üñ± Connect geklickt');
      try {
        if (hasRPC()) {
          await window.flipper.connect();
          log('‚úÖ Verbunden (RPC). Warte auf Ausgabe‚Ä¶', 'ok');
          setRPC(true, 'connected');
          // RPC-Session starten (falls im Bundle so vorgesehen)
          try {
            if (window.flipper.commands && typeof window.flipper.commands.startRpcSession === 'function') {
              await window.flipper.commands.startRpcSession();
              log('‚úÖ RPC-Session gestartet', 'ok');
            }
          } catch (e) { log('‚ö†Ô∏è Konnte RPC-Session nicht starten: ' + e, 'bad'); }
        } else {
          await fallbackConnect();
          setRPC(false, 'fallback');
        }
        enableConnectedUI(true);
      } catch (err) {
        log('‚ùå Fehler beim Verbinden: ' + err, 'bad');
      }
    });

    $btnDisconnect.addEventListener('click', async () => {
      log('üñ± Disconnect geklickt');
      try {
        if (hasRPC()) await window.flipper.disconnect();
        else await fallbackDisconnect();
      } catch (err) {
        log('‚ùå Fehler beim Trennen: ' + err, 'bad');
      } finally {
        enableConnectedUI(false);
      }
    });

    $btnReboot.addEventListener('click', async () => {
      log('üñ± Reboot senden');
      try {
        if (hasRPC() && window.flipper.commands.system && typeof window.flipper.commands.system.reboot === 'function') {
          await window.flipper.commands.system.reboot('os');
          log('üîÑ Reboot per RPC gesendet', 'ok');
        } else {
          await fallbackWrite('reboot\r');
          log('üîÑ Reboot per CLI gesendet', 'ok');
        }
      } catch (e) {
        log('‚ùå Fehler beim Reboot: ' + e, 'bad');
      }
    });

    $btnPing.addEventListener('click', async () => {
      log('üñ± Ping');
      try {
        if (hasRPC() && window.flipper.commands.system && typeof window.flipper.commands.system.ping === 'function') {
          const r = await window.flipper.commands.system.ping();
          log('üèì Ping OK: ' + JSON.stringify(r), 'ok');
        } else {
          await fallbackWrite('help\r');
          log('üìú Hilfe per CLI angefordert (Fallback)', 'ok');
        }
      } catch (e) {
        log('‚ùå Ping/Help-Fehler: ' + e, 'bad');
      }
    });

    $btnSend.addEventListener('click', async () => {
      const cmd = $cliInput.value.trim();
      if (!cmd) return;
      $cliInput.value = '';
      try {
        if (hasRPC()) {
          // Optional: RPC-spezifische Befehle hier mappen
          await window.flipper.write('cli', cmd + '\r');
        } else {
          await fallbackWrite(cmd + '\r');
        }
        log('‚ñ∂Ô∏è ' + cmd, 'muted');
      } catch (e) {
        log('‚ùå CLI-Fehler: ' + e, 'bad');
      }
    });
    $cliInput.addEventListener('keydown', (e) => {
      if (e.key === 'Enter') $btnSend.click();
    });

    // Upload .tgz ‚Üí /ext/update/<name>.tgz
    $btnUpload.addEventListener('click', async () => {
      if (!$fwFile.files.length) { log('‚ö†Ô∏è Keine Firmware-Datei ausgew√§hlt!', 'bad'); return; }
      if (!hasRPC()) { log('‚ùå RPC nicht verf√ºgbar ‚Äì Upload via RPC nicht m√∂glich.', 'bad'); return; }
      const file = $fwFile.files[0];
      log('üì¶ Lade Firmware: ' + file.name);
      try {
        setBar(0);
        const u8 = await fileToU8(file);
        const target = '/ext/update/' + file.name;
        if (!(window.flipper.commands && window.flipper.commands.storage && typeof window.flipper.commands.storage.write === 'function')) {
          throw new Error('commands.storage.write fehlt');
        }
        log('‚û°Ô∏è Upload starte: ' + target);
        await window.flipper.commands.storage.write(target, u8); // RPC chunked write (512B)
        setBar(100);
        log('‚úÖ Upload abgeschlossen: ' + target, 'ok');
      } catch (e) {
        log('‚ùå Fehler beim Upload: ' + e, 'bad');
      }
    });

    // Update starten (RPC): Manifest extrahieren & system.update(manifest)
    $btnUpdate.addEventListener('click', async () => {
      if (!$fwFile.files.length) { log('‚ö†Ô∏è Keine Firmware-Datei ausgew√§hlt!', 'bad'); return; }
      if (!hasRPC()) { log('‚ùå RPC nicht verf√ºgbar ‚Äì Update via RPC nicht m√∂glich.', 'bad'); return; }
      const file = $fwFile.files[0];

      try {
        const u8 = await fileToU8(file);
        log('üß© Extrahiere update.fuf aus TGZ‚Ä¶');
        const fuf = findUpdateFufInTgz(u8);
        if (!fuf) {
          log('‚ö†Ô∏è Konnte update.fuf nicht finden ‚Äì Update kann nicht automatisch gestartet werden.', 'bad');
          return;
        }
        if (!(window.flipper.commands && window.flipper.commands.system && typeof window.flipper.commands.system.update === 'function')) {
          throw new Error('commands.system.update fehlt');
        }
        log('üöÄ Sende system.update(updateManifest)‚Ä¶');
        const res = await window.flipper.commands.system.update(fuf);
        log('‚úÖ Update-Request gesendet: ' + JSON.stringify(res || {}), 'ok');
        log('‚ÑπÔ∏è Beobachte Flipper-Bildschirm f√ºr Update-Fortschritt.');
      } catch (e) {
        log('‚ùå Fehler beim Update: ' + e, 'bad');
      }
    });

    // ------------- Init -------------
    (function init() {
      log('üì¢ Seite geladen');
      setWS(('serial' in navigator), ('serial' in navigator) ? 'ok' : 'fehlt');
      setRPC(!!(window.flipper && window.flipper.commands), window.flipper && window.flipper.commands ? 'ready' : 'unbekannt');
      enableConnectedUI(false);

      // kleine Diagnose
      try {
        log('üì¢ protobuf vorhanden? ' + (typeof protobuf !== 'undefined'), 'muted');
      } catch {}
      try {
        log('üì¢ window.flipper vorhanden? ' + (typeof window.flipper !== 'undefined'), 'muted');
      } catch {}
    })();
  </script>
</body>
</html>
